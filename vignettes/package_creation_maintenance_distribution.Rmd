---
title: "Package creation, maintenance and distribution - From development to lifecycle"
output: rmarkdown::html_vignette
description: |
  Description methodology, good practicies and lifecycle package creation and management".
vignette: |
  %\VignetteIndexEntry{Package creation, maintenance and distribution - From development to lifecycle}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<div style="text-align: justify">

## 1. Package development

### Package skeleton creation

### Dependencies

Using functions from other packages can save you time and effort in development but it might make it more difficult to maintain your package. Deciding which packages (and how many) to depend on is a difficult and philosophical choice. Some things you might want to consider before depending on a package are:

* How much of the functionality of the package do you want to use?
* Could you easily reproduce that functionality?
* How well maintained is the package?
* How often is it updated? Packages that change a lot are more likely to break your code.
* How many dependencies of it’s own does that package have?
* Are you users likely to have the package installed already?

When it's clear in your mind that the best solution is to use function(s) from other packages, you have to specify in your package what kind of dependency you have. There are three main types of dependencies:

* `imports` - this means that we use functions from these packages and they must be installed when our pacakge is installed.
* `suggests` - these are packages that we use in developing our package (such as [testthat](https://testthat.r-lib.org/)) or packages that provide some additional, optional functionality. These packages aren't usually installed and you need to do a check before using them.
* `depends` - shouldn’t usually be used unless your package closely complements another package. For example, depends is necessary is if you package mainly operates on an object defined by another package.

To declare a dependency, the best way is to use the function [use_package](https://usethis.r-lib.org/reference/use_package.html). In practice, we advise advice to an optionally argument of the function, min_version, which specify what is the minimum version of the package that you have to install, according to the version that you have on your computer. With that, you reduce the risk of incompatibility when you share your package to other people.

```{r use_package, eval=FALSE, include=TRUE}
# if you want to add a package present on the CRAN
usethis::use_package(package = "package_name",
                     type = "Imports",
                     min_version = TRUE)
# if you wan to add a package from an in-development package, from a Git repository for example
usethis::use_dev_package(package = "package_name",
                         type = "Imports",
                         remote = "remote_path")
# for the remote syntax check the documentation here: https://remotes.r-lib.org/articles/dependencies.html
```

When you add a dependency through this process you should have a message like that:

```{r message use_package, eval=FALSE, include=TRUE}
Refer to functions with `package_name::fun()`
```

In our code you have two solutions:

* when you call a function from another package, call with the syntax `package_name::function_name()`
* write the call of the function without package_name:: and add in NAMESPACE file the line `importFrom(package_name,function_name)`. You can add this line by hand in theory, but it's highly recommended to use the documentation generation of roxygen2 with the syntax `#' @importFrom package_name function_name` (take a look to the section X.X dedicates to the documentation generation). If a function has the same name in different packages, use the first codification to avoid any mistake.

If the function associated to the explanation above appear several time in our package, you can only import it once. It doesn’t matter where we put the `@importFrom` line (or how many times) it will still be added to `NAMESPACE`. This means we can put all import in a central location. The advantage of this is that they only appear once and are all in one place but it makes it harder to know which of our functions have which imports and remove them if they are no longer needed. Which approach you take is up to you.

### Documentation

Today, it's impossible to find a modern package without documentation associated. Document your code and globally your software is an essential part of his development. Do without is a very dangerous way which may cause problems in the future, especially if you work with several colleagues or even if you package became complex. Historically painful, this process is well assisted, especially with the association to other packages. Furthermore, you will see that there are several "level" of documentation and each have specific and transversal aims.

#### Documenting functions

Documenting functions is the first step of the global documentation process. This kind of documentation will produce user information, like the arguments of your function, who to specify them and some other specification like what your function return. The way to doing that has been made much easier by modern package, especilly one collaed [roxygen2](https://roxygen2.r-lib.org/). R help files use a complicated syntax similar to LaTeX that can be easy to mess up. Instead of writing this all ourselves using Roxygen lets us just write some special comments at the start of each function. This has the extra advantage of keeping the documentation with the code which make it easier to keep it up to date. 

Roxygen process work through tags that you will add at the begging of your code. Tag's syntax begin with `#' ` associated to `@something` for call a specific tag. For start, you can generate a Roxygen skeleton from your function in RStudio, by opne the *Code* menu and select *Roxygen skeleton*.

There are a [lot of tags](https://roxygen2.r-lib.org/reference/index.html#tags) that you can use but you will find below the "most" common and useful:

* `@name` - Define the topic name (same name as your function below the documentation).
* `@title` - Define the title of your documentation. 
* `@description` - Describre 
* `@param` - Describe a function input. Should describe acceptable input types and how it affects the output. The syntax is `name` follwing by a space and `description`. The description is usually one or two sentences but can be as long as needed. Document multiple arguments by separating their names with commas without spaces.
* `@return` - Describe the function's output. Typically will be a 1-2 sentence description of the output type, but might also include discussion of important errors or warnings.
* `@details` - Additional details about the function.
* `@examples` - Executable R code that demonstrates how the function works. Code must run without error.
* `@examplesIf` - The syntax is `TRUE` or `FALSE` following on the next line by an example code. Run examples only when condition is `TRUE`.
* `@importFrom` - Write in the NAMESPACE file which function(s) you use in our code from which package(s). 
* `@export` - Adding in the NAMESPACE that this is a function that we want to be available to the user. If we had an internal function that wasn’t meant to be used by the user we would leave out `@export`.
* `@keywords` - Initially use for increase the efficient of the searching process dealing with you package, if you add `@keywords internal` you will remove the function from the documentation index. It’s useful if you want to create a global documentation help when you write ?package_name in the R console.

For bulding your documentation you can click on the section `Build` on the RStudio interface, `More` with the gear logo and `Document`. You can also launch the following code:

```{r documentation, eval=FALSE, include=TRUE}
devtools::document()
```

It's also advising configuring an update of the documentation when you compile your package. You have to configure that once through the `Configuration Build Tools` menu (section `Build` and subsection `More`) in the tab `Configure` near the ticked line `Generate documentation with Roxygen`.

### Checking and testing

Verify your package is one of the thing that you have to do many and many time, especially if you modify the code or add new functions. Run the process frequently should simplify your development and corrections should improve your code writing in the future. Typically, there are two kinds of verification, the checking and the testing.

#### Checking

Aim of this point is to check that your package don't have any mistake in term of structure and syntax. This is essential if you want to submit your package to CRAN because you must not have any errors or warnings. For doing that the most easier way is to launch the following code in the package directory:

```{r devtools checks, eval=FALSE, include=TRUE}
devtools::check()
```

You should saw several outputs with at the end a subdivision of three parts: errors, warnings and notes. The goals is to have 0 error or warning and less a possible notes. Errors happen when you code has broken and failed one of the checks. If errors are not fixed your package will not work correctly. Warnings are slightly less serious but should also be addressed. Your package will probably work without fixing thise but it is highly advised that you do. Notes are advice rather than problems. It can be up to you whether or not to address them but there is usally a good reason to. Keep in your mind that the checking process will stop if we encount an error. Information about the error will be display in the output, but the correction of it does not guarantee that you shouldn't have another error occur (this is a sequential process). Everything work fine when you have at the end only notes or in the best case nothing.

#### Testing 

Testing your package is the section kind of verification that you can do. The function `devtools::check()` verify that our package passes standard checks, like for the typing or code/package structure, but we don't verify that our functions work in the way that we expect. This is where unit tests highlight. One approach to writing unit tests is what is known as "test-driven development". The idea here is to write the tests before you write a function. This way you know exactly what a function is supposed to do and what problems there might be. While this is a good principle, it can take a lot of advance planning. A more common approach could be called “bug-driven testing”. For this approach whenever we come across a bug, we write a test for it before we fix it, that way the same bug should never happen an again. When combined with some tests for obvious problems, this is a good compromise better testing for every possible outcome and not testing at all.

There are a few ways to write unit tests for R packages but one of the easier way is to use the [testthat](https://testthat.r-lib.org/) package. We can set everything up with the following command line:

```{r testthat initialisation, eval=FALSE, include=TRUE}
usethis::use_testthat()
```



### 1. Git and GitHub

[Happy Git and GitHub for the useR ](https://happygitwithr.com/)


### 2. Continuous Integration and Developement (CI/CD)

During all the life of a package, you will be confronted several times to a special moment: you development a new function or a new piece of code and you have to integrate them in the source code. The key question here is to ask yourself if you code will does not produce regression in the developed application. The aims of the Continuous Integration (CI) and Continuous Development (CD) is to detected problems soon as possible in the development phase, automate execution of tests and verification and, in a global view, monitor and manage the progress of our software development.    

### 2.1. GitHub Actions (GHA)

[GitHub Actions for the R language](https://github.com/r-lib/actions/#readme)

[usethis::use_github_action()](https://usethis.r-lib.org/reference/use_github_action.html)

[workflows examples](https://github.com/r-lib/actions/tree/v2/examples)

[check-release](https://github.com/r-lib/actions/blob/v2/examples/check-release.yaml): a "simple" workflow to check your package with the release version of R on ubuntu (latest version available).

[check-standard](https://github.com/r-lib/actions/blob/v2/examples/check-standard.yaml): recommended for any package that is, or aspires to be on the CRAN. This process runs R CMD check across a few combinations of operating system and R version. In addition, the usethis process add a badge reporting the R CMD check result in the README file.

[check-full](https://github.com/r-lib/actions/blob/v2/examples/check-full.yaml): the more complex verification check.

[lint](https://github.com/r-lib/actions/blob/v2/examples/lint.yaml): run function lintr::lint_package() on an R package. The package [lintr](https://lintr.r-lib.org/) provides a static code analysis for R (analysis of the code without executing them, in opposition to a dynamic program analysis). It's a very useful way to check our code and identify mistakes or non-compliance of good practices.

[pkgdown](https://github.com/r-lib/actions/blob/v2/examples/pkgdown.yaml): build a [pkgdown](https://pkgdown.r-lib.org/) site for an R package and deploy it to [GitHub Pages](https://pages.github.com/). Pkgdown is an R package designed to make quickly and easily a package website.

### 2.2. Building package's website

[usethis::use_pkgdown_github_pages()](https://usethis.r-lib.org/reference/use_github_pages.html)

### 2.3. Versioning

Using the good practices in package development, like use an Integrated Development Environment (IDE, like RStudio), a version control system like Git or any process of CI, is useless if you don't have a good versioning system of your package. It's more important and relevant when it comes to things like solving user issues or deploy/share your work with others peoples.

For R developement, the version number follow the following format `major.minor.patch.dev`. Each part of the version represent different things:

* `major` - A significant change to the package that would be expected to break users code.
* `minor` - A minor version update means that new functionality has been added to the package. It might be new functions to improvements to existing functions that are compatible with most existing code.
* `patch` - Patch updates are bug fixes. They solve existing issues but don’t do anything new.
* `dev` - Dev versions are used during development and this part is missing from release versions (you will only find version number in the format `major.minor.patch`). For example you might use a dev version when you give someone a beta version to test. A package with a dev version can be expected to change rapidly or have undiscovered issues.

In practice, the function `use_version()` (from the package `usethis`,  documentation associated [here](https://usethis.r-lib.org/reference/use_version.html)) can provide a clever support for updating your package version. If your package is associated with a Git repository, you can also prepare a commit for version updated.

```{r use_version example, eval=FALSE, include=TRUE}
# for interactive selection
usethis::use_version()

# for specify a level of increment. 
# you can choose in the argument which between "major", "minor", "patch" or "dev".
# the process will propose to you to create a commit associated with the updated version.
# with the argument push = TRUE (by default FALSE) you can directly make a commit and push it on the repository associated.
usethis::use_version(which = "dev",
                     push = TRUE)
```

In addition to the update of your package version number, it's important to record what changes have been made. For that, good practices suggest to create a new markdown file, called NEWS.md, at the edge of your package directory. Another function, [`use_news_md`](https://usethis.r-lib.org/reference/use_news_md.html) can help you can create the initial file template. 

```{r news file, eval=FALSE, include=TRUE}
# creation of the NEWS.md file
usethis::use_news_md()
```

You are free to structure your NEWS.md file like you want but we recommend at least to have this kind of structure (use only section useful for your release/dev version):

```{r news file template, eval=FALSE, include=TRUE}
# package_name major.minor.patch.dev - year-month-day

## Added
* Code added n°1
* Code added n°x

## Changed
* Code changed n°1
* Code changed n°x

## Removed
* Code removed n°1
* Code removed n°x
```

## 3. Lifecyle

## References

This vignette was made according to the guidelines and advises provided by several resources (many thanks to them !). You will find below the identification and links (if available) associated.

[R package development workshop](https://combine-australia.github.io/r-pkg-dev/)

[R Packagesp](https://r-pkgs.org/)

</div>
